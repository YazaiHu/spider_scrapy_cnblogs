{"title": ["[置顶]ASP.NET Core框架揭秘（持续更新中…）"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-core-1.html"], "desc": ["摘要: ", "之前写了一系列关于.NET Core/ASP.NET Core的文章，但是大都是针对RC版本。到了正式的RTM，很多地方都发生了改变，所以我会将之前发布的文章针对正式版本的.NET Core 1.0进行改写。除此之外，我还会撰写一系列与此相关的文章，这些文章以ASP.NET Core为核心，我个人将它们分成三个主要的部分，即编程基础、支撑框架和管道详解。其中编程基础主要涉及与ASP.NET Core独特的编程模型和相关编程技巧。支撑框架则介绍支撑ASP.NET Core的多个独立的框架，比如依赖注入、配置模型、配置管理等等。至于最后一部分管道详解，我们会介绍ASP.NET Core最为核心的部分，即用以处理请求的管道"]}
{"title": ["通过重建Hosting系统理解HTTP请求在ASP.NET Core管道中的处理流程[下]：管道是如何构建起来的？"], "link": ["http://www.cnblogs.com/artech/p/rebuild-pipeline-03.html"], "desc": ["摘要: ", "ASP.NET Core请求处理管道由一个服务器和一组中间件构成。如果想非常深刻地认识ASP.NET Core的请求处理管道，我觉得可以分两个步骤来进行：首先，我们可以在忽略具体细节的前提下搞清楚管道处理HTTP请求的总体流程；在对总体流程有了大致了解之后，我们再来补充这些刻意忽略的细节。为了让读者朋友们能够更加容易地理解管道处理HTTP请求的总体流程，我们根据真实管道的实现原理再造了一个“迷你版的管道”。"]}
{"title": ["通过重建Hosting系统理解HTTP请求在ASP.NET Core管道中的处理流程[中]：管道如何处理请求"], "link": ["http://www.cnblogs.com/artech/p/rebuild-pipeline-02.html"], "desc": ["摘要: ", "ASP.NET Core请求处理管道由一个服务器和一组中间件构成。如果想非常深刻地认识ASP.NET Core的请求处理管道，我觉得可以分两个步骤来进行：首先，我们可以在忽略具体细节的前提下搞清楚管道处理HTTP请求的总体流程；在对总体流程有了大致了解之后，我们再来补充这些刻意忽略的细节。为了让读者朋友们能够更加容易地理解管道处理HTTP请求的总体流程，我们根据真实管道的实现原理再造了一个“迷你版的管道”。"]}
{"title": ["通过重建Hosting系统理解HTTP请求在ASP.NET Core管道中的处理流程[上]：采用管道处理请求"], "link": ["http://www.cnblogs.com/artech/p/rebuild-pipeline-01.html"], "desc": ["摘要: ", "ASP.NET Core请求处理管道由一个服务器和一组中间件构成。如果想非常深刻地认识ASP.NET Core的请求处理管道，我觉得可以分两个步骤来进行：首先，我们可以在忽略具体细节的前提下搞清楚管道处理HTTP请求的总体流程；在对总体流程有了大致了解之后，我们再来补充这些刻意忽略的细节。为了让读者朋友们能够更加容易地理解管道处理HTTP请求的总体流程，我们根据真实管道的实现原理再造了一个“迷你版的管道”。"]}
{"title": [".NET Core的文件系统[5]：扩展文件系统构建一个简易版“云盘”"], "link": ["http://www.cnblogs.com/artech/p/net-core-file-provider-05.html"], "desc": ["摘要: ", "FileProvider构建了一个抽象文件系统，作为它的两个具体实现，PhysicalFileProvider和EmbeddedFileProvider则分别为我们构建了一个物理文件系统和程序集内嵌文件系统。总的来说，它们针对的都是“本地”文件，接下来我们通过自定义FileProvider构建一个“远程”文件系统，我们可以将它视为一个只读的“云盘”。由于文件系统的目录结构和文件内容都是通过HTTP请求的方式读取的，所以我们将这个自定义的FileProvider命名为HttpFileProvider。"]}
{"title": ["[WCF]缺少一行代码引发的血案"], "link": ["http://www.cnblogs.com/artech/p/5892586.html"], "desc": ["摘要: ", "这是今天作项目支持的发现的一个关于WCF的问题，虽然最终我只是添加了一行代码就解决了这个问题，但是整个纠错过程是痛苦的，甚至最终发现这个问题都具有偶然性。具体来说，这是一个关于如何自动为服务接口（契约）的每个操作添加FaultContract与WCF服务元数据发布的问题。接下来通过一个简单的实例来说明这个因为少写了一行代码引发的血案。"]}
{"title": ["如何利用ETW（Event Tracing for Windows）记录日志"], "link": ["http://www.cnblogs.com/artech/p/logging-via-etw.html"], "desc": ["摘要: ", "ETW是Event Tracing for Windows的简称，它是Windows提供的原生的事件跟踪日志系统。由于采用内核（Kernel）层面的缓冲和日志记录机制，所以ETW提供了一种非常高效的事件跟踪日志解决方案。"]}
{"title": [".NET Core的日志[5]:利用TraceSource写日志"], "link": ["http://www.cnblogs.com/artech/p/logging-for-net-core-05.html"], "desc": ["摘要: ", "从微软推出第一个版本的.NET Framework的时候，就在“System.Diagnostics”命名空间中提供了Debug和Trace两个类帮助我们完成针对调试和跟踪信息的日志记录。在.NET Framework 2.0中，微软引入了TraceSource并对跟踪日志系统进行了优化，优化后的跟踪日志系统在.NET Core中又经过了相应的简化。.NET Core的日志模型借助TraceSourceLoggerProvider实现对TraceSource的整合，在正式介绍这个Logger之前，我们先来认识一下TraceSource跟踪日志系统中的三个核心对象"]}
{"title": [".NET Core的日志[4]:将日志写入EventLog"], "link": ["http://www.cnblogs.com/artech/p/logging-for-net-core-04.html"], "desc": ["摘要: ", "面向Windows的编程人员应该不会对Event Log感到陌生，以至于很多人提到日志，首先想到的就是EventLog。EventLog不仅仅记录了Windows系统自身针对各种事件的日志，我们的应用也可以利用提供的API将日志消息写到EventLog中。与EventLog相关的API都定义在System.Diagnostics.EventLog这个类型中，我们不仅仅可以利用它读取、写入和删除日志，还可以使用它来创建和删除Event Source。.NET Core的日志模型利用EventLogLogger实现了与EventLog的集成，不过EventLogLogger使用的是一个抽象化的EventLog。"]}
{"title": [".NET Core的日志[3]:将日志写入Debug窗口"], "link": ["http://www.cnblogs.com/artech/p/logging-for-net-core-03.html"], "desc": ["摘要: ", "定义在NuGet包“Microsoft.Extensions.Logging.Debug”中的DebugLogger会直接调用Debug的WriteLine方法来写入分发给它的日志消息。如果需要使用DebugLogger来写日志，我们需要将它的提供者DebugLoggerProvider注册到LoggerFactory上。由于定义在Debug类型中的所有方法都是针对Debug编译模式的，所以在只有针对Debug模式编译的应用中使用DebugLogger才有意义。这里将的“Debug编译模式”涉及到一个叫做“条件编译”的话题。"]}
{"title": [".NET Core的日志[2]:将日志输出到控制台"], "link": ["http://www.cnblogs.com/artech/p/logging-for-net-core-02.html"], "desc": ["摘要: ", "对于一个控制台应用，比如采用控制台应用作为宿主的ASP.NET Core应用，我们可以将记录的日志直接输出到控制台上。针对控制台的Logger是一个类型为ConsoleLogger的对象，ConsoleLogger对应的LoggerProvider类型为ConsoleLoggerProvider，这两个类型都定义在 NuGet包“Microsoft.Extensions.Logging.Console”之中。"]}
{"title": [".NET Core采用的全新配置系统[10]: 配置的同步机制是如何实现的？"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-10.html"], "desc": ["摘要: ", "配置的同步涉及到两个方面：第一，对原始的配置文件实施监控并在其发生变化之后从新加载配置；第二，配置重新加载之后及时通知应用程序进而使后者能够使用最新的配置。要了解配置同步机制的实现原理，先得从认识一个名为ConfigurationReloadToken的类型开始。"]}
{"title": [".NET Core的日志[1]:采用统一的模式记录日志"], "link": ["http://www.cnblogs.com/artech/p/logging-for-net-core-01.html"], "desc": ["摘要: ", "记录各种级别的日志是所有应用不可或缺的功能。关于日志记录的实现，我们有太多第三方框架可供选择，比如Log4Net、NLog、Loggr和Serilog 等，当然我们还可以选择微软原生的诊断框架（相关API定义在命名空间“System.Diagnostics”中）实现对日志的记录。.NET Core提供了独立的日志模型使我们可以采用统一的API来完成针对日志记录的编程，我们同时也可以利用其扩展点对这个模型进行定制，比如可以将上述这些成熟的日志框架整合到我们的应用中。"]}
{"title": [".NET Core采用的全新配置系统[9]: 为什么针对XML的支持不够好？如何改进？"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-09.html"], "desc": ["摘要: ", "物理文件是我们最常用到的原始配置的载体，最佳的配置文件格式主要由三种，它们分别是JSON、XML和INI，对应的配置源类型分别是JsonConfigurationSource、XmlConfigurationSource和IniConfigurationSource。但是对于.NET Core的配置系统来说，我们习以为常的XML反倒不是理想的配置源，至少和JSON比较起来，它具有一个先天不足的劣势，那就是针对集合数据结构的支持不如人意。["]}
{"title": [".NET Core采用的全新配置系统[8]: 如何实现配置与源文件的同步"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-08.html"], "desc": ["摘要: ", "配置的同步涉及到两个方面：第一，对原始的配置文件实施监控并在其发生变化之后从新加载配置；第二，配置重新加载之后及时通知应用程序进而使后者能够使用最新的配置。接下来我们利用一个简单的.NET Core控制台应用来演示针对文件的配置会涉及到数据同步的问题，我们希望应用能够对原始配置文件实施监控，并在文件内容发生改变的时候从新加载并应用新的配置。"]}
{"title": [".NET Core采用的全新配置系统[7]: 将配置保存在数据库中"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-07.html"], "desc": ["摘要: ", "如果预定义的ConfigurationSource依然不能满足项目中的配置需求，我们可以还可以通过自定义ConfigurationSource来支持我们希望的配置来源。就配置数据的持久化方式来说，将培植存储在数据库中应该是一种非常常见的方式，接下来我们就是创建一个针对数据库的ConfigurationSource，它采用最新的Entity Framework Core来完成数据库的存取操作。"]}
{"title": [".NET Core采用的全新配置系统[6]: 深入了解三种针对文件（JSON、XML与INI）的配置源"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-06.html"], "desc": ["摘要: ", "物理文件是我们最常用到的原始配置的载体，最佳的配置文件格式主要由三种，它们分别是JSON、XML和INI，对应的配置源类型分别是JsonConfigurationSource、XmlConfigurationSource和IniConfigurationSource。"]}
{"title": [".NET Core采用的全新配置系统[5]: 聊聊默认支持的各种配置源[内存变量,环境变量和命令行参数]"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-05.html"], "desc": ["摘要: ", "较之传统通过App.config和Web.config这两个XML文件承载的配置系统，.NET Core采用的这个全新的配置模型的最大一个优势就是针对多种不同配置源的支持。我们可以将内存变量、命令行参数、环境变量和物理文件作为原始配置数据的来源，如果采用物理文件作为配置源，我们可以选择不同的格式(比如XML、JSON和INI等) 。如果这些默认支持的配置源形式还不能满足你的需求，我们还可以通过注册自定义ConfigurationSource的方式将其他形式数据作为我们的配置来源。"]}
{"title": [".NET Core的文件系统[4]：由EmbeddedFileProvider构建的内嵌（资源）文件系统"], "link": ["http://www.cnblogs.com/artech/p/net-core-file-provider-04.html"], "desc": ["摘要: ", "一个物理文件可以直接作为资源内嵌到编译生成的程序集中。借助于EmbeddedFileProvider，我们可以统一的编程方式来读取内嵌于某个程序集中的资源文件"]}
{"title": [".NET Core的文件系统[3]：由PhysicalFileProvider构建的物理文件系统"], "link": ["http://www.cnblogs.com/artech/p/net-core-file-provider-03.html"], "desc": ["摘要: ", "ASP.NET Core应用中使用得最多的还是具体的物理文件，比如配置文件、View文件以及网页上的静态文件，物理文件系统的抽象通过PhysicalFileProvider这个FileProvider来实现，该类型定义在NuGet包“Microsoft.Extensions.FileProviders.Physical”中。我们知道System.IO命名空间下定义了一整套针操作物理目录和文件的API，实际上PhysicalFileProvider最终也是通过调用这些API来完成相关的IO操作的。["]}
{"title": [".NET Core的文件系统[2]：FileProvider是个什么东西？"], "link": ["http://www.cnblogs.com/artech/p/net-core-file-provider-02.html"], "desc": ["摘要: ", "在《读取并监控文件的变化》中，我们通过三个简单的实例演示从编程的角度对文件系统做了初步的体验，接下来我们继续从设计的角度来继续认识它。这个抽象的文件系统以目录的形式来组织文件，我们可以利用它读取某个文件的内容，还可以对目标文件试试监控并捕捉它的变化。这些基本的功能均由相应的FileProvider来提供，从某种意义上讲FileProvider代表了整个文件系统。"]}
{"title": [".NET Core的文件系统[1]：读取并监控文件的变化"], "link": ["http://www.cnblogs.com/artech/p/net-core-file-provider-01.html"], "desc": ["摘要: ", "ASP.NET Core 具有很多针对文件读取的应用。比如我们倾向于采用JSON文件来定义配置，所以应用就会涉及针对配置文件读取。如果用户发送一个针对物理文件的HTTP请求，应用会根据指定的路径读取目标文件的内容并对请求予以响应。在一个ASP.NET Core MVC应用中，针对View的动态编译会涉及到根据预定义的路径映射关系来读取目标View。这些不同应用场景都会出现一个FileProvider对象的身影，以此对象为核心的文件系统提供了统一的API来读取文件的内容并监控内容的改变。"]}
{"title": [".NET Core采用的全新配置系统[4]: “Options模式”下各种类型的Options对象是如何绑定的？"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-04.html"], "desc": ["摘要: ", "旨在生成Options对象的配置绑定实现在IConfiguration接口的扩展方法Bind上。配置绑定的目标类型可以是一个简单的基元类型，也可以是一个自定义数据类型，还可以是一个数组、集合或者字典类型。通过前面的介绍我们知道ConfigurationProvider将原始的配置数据读取出来后会将其转成Key和Value均为字符串的数据字典，那么针对这些完全不同的目标类型，原始的配置数据如何通过数据字典的形式来体现呢？"]}
{"title": [".NET Core采用的全新配置系统[3]: “Options模式”下的配置是如何绑定为Options对象"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-03.html"], "desc": ["摘要: ", "置的原子结构就是单纯的键值对，并且键和值都是字符串，但是在真正的项目开发中我们一般不会单纯地以键值对的形式来使用配置。值得推荐的做法就是将相关的配置定义成一个Options类型，并采用与类型定义想匹配的结构来定义原始的配置，这样就能利用它们之间的映射关系将读取的配置数据绑定为Options对象，我们将这种编程模式称为“Options模式”。"]}
{"title": [".NET Core采用的全新配置系统[2]: 配置模型设计详解"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-02.html"], "desc": ["摘要: ", "在《.NET Core采用的全新配置系统[1]: 读取配置数据》中，我们通过实例的方式演示了几种典型的配置读取方式，其主要目的在于使读者朋友们从编程的角度对.NET Core的这个全新的配置系统具有一个大体上的认识，接下来我们从设计的维度来重写认识它。通过上面演示的实例我们知道，配置的编程模型涉及到三个核心对象，它们分别是Configuration、ConfigurationSource和ConfigurationBuilder。如果从设计层面来审视这个配置系统，还缺少另一个名为ConfigurationProvider的核心对象，总得来说，.NET Core的这个配置模型由这四个核心对象组成。"]}
{"title": [".NET Core采用的全新配置系统[1]: 读取配置数据"], "link": ["http://www.cnblogs.com/artech/p/new-config-system-01.html"], "desc": ["摘要: ", "提到“配置”二字，我想绝大部分.NET开发人员脑海中会立马浮现出两个特殊文件的身影，那就是我们再熟悉不过的app.config和web.config，多年以来我们已经习惯了将结构化的配置定义在这两个文件之中。到了.NET Core的时代，很多我们习以为常的东西都发生了改变，其中也包括定义配置的方式。总的来说，新的配置系统显得更加轻量级，并且具有更好的扩展性，其最大的特点就是支持多样化的数据源。我们可以采用内存的变量作为配置的数据源，也可以直接配置定义在持久化的文件甚至数据库中。"]}
{"title": ["ASP.NET Core框架揭秘（持续更新中…）"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-core-1.html"], "desc": ["摘要: ", "之前写了一系列关于.NET Core/ASP.NET Core的文章，但是大都是针对RC版本。到了正式的RTM，很多地方都发生了改变，所以我会将之前发布的文章针对正式版本的.NET Core 1.0进行改写。除此之外，我还会撰写一系列与此相关的文章，这些文章以ASP.NET Core为核心，我个人将它们分成三个主要的部分，即编程基础、支撑框架和管道详解。其中编程基础主要涉及与ASP.NET Core独特的编程模型和相关编程技巧。支撑框架则介绍支撑ASP.NET Core的多个独立的框架，比如依赖注入、配置模型、配置管理等等。至于最后一部分管道详解，我们会介绍ASP.NET Core最为核心的部分，即用以处理请求的管道"]}
{"title": ["学习ASP.NET Core，你必须了解无处不在的“依赖注入”"], "link": ["http://www.cnblogs.com/artech/p/dependency-injection-in-asp-net-core.html"], "desc": ["摘要: ", "ASP.NET Core的核心是通过一个Server和若干注册的Middleware构成的管道，不论是管道自身的构建，还是Server和Middleware自身的实现，以及构建在这个管道的应用，都需要相应的服务提供支持，ASP.NET Core自身提供了一个DI容器来实现针对服务的注册和消费。换句话说，不只是ASP.NET Core底层框架使用的服务是由这个DI容器来注册和提供，应用级别的服务的注册和提供也需要以来这个DI容器，所以正如本文标题所说的——学习ASP.NET Core，你必须了解无处不在的“依赖注入”。"]}
{"title": ["通过几个Hello World感受.NET Core全新的开发体验"], "link": ["http://www.cnblogs.com/artech/p/net-core-hello-world.html"], "desc": ["摘要: ", "2016年6月27日，这是一个特殊的日子，微软全新的.NET开发平台.NET Core的RTM版本正式发布。我个人将.NET Core的核心特性归结为三点，它们的首字母组成一个非常好记的简称——COM，分别代表的含义Cross-Platform、Open-Source和Modularization。开发.NET Core应用的方式与之前具有非常大的变化，对于那些尚未体验过.NET Core的朋友，我希望通过本篇文章创建的这一个Hello World应用可以很容易地带你们入门。"]}
{"title": ["如果没有Visual Studio 2015，我们如何创建.NET Core项目 ？"], "link": ["http://www.cnblogs.com/artech/p/scaffolding-net-core.html"], "desc": ["摘要: ", "对于.NET开发人员来说，我们已经习惯了VS这个世界上最强大的IDE，所以对他们来说，项目的创建直接利用安装到VS中相应的项目模板即可。当.NET Core跨出了Windows的围栏，正式拥抱其他平台，意味着VS已经不再是唯一的IDE。于此同时，.NET Core充分借鉴了目前非常流行的基于“脚手架（Scaffolding）”的源文件生成方式，在它的核心命令行“dotnet”也添加了脚手架的命令行开关。除此之外，.NET Core真正对社区敞开胸怀，我们可以直接利用现有的脚手架工具Yeoman来生成.NET Core项目。接下来我们就来介绍一下两种生成.NET Core项目的方式。"]}
{"title": ["如果你想深刻理解ASP.NET Core请求处理管道，可以试着写一个自定义的Server"], "link": ["http://www.cnblogs.com/artech/p/stomized-server.html"], "desc": ["摘要: ", "我们在上面对ASP.NET Core默认提供的具有跨平台能力的KestrelServer进行了详细介绍（《聊聊ASP.NET Core默认提供的这个跨平台的服务器——KestrelServer》），为了让读者朋友们对管道中的Server具有更加深刻的认识，接下来我们采用实例演示的形式创建一个自定义的Server。这个自定义的Server直接利用HttpListener来完成针对请求的监听、接收和响应，我们将其命名为HttpListenerServer。在正式介绍HttpListenerServer的设计和实现之前，我们先来显示一下如何将它应用到 一个具体的Web应用中。"]}
{"title": ["聊聊ASP.NET Core默认提供的这个跨平台的服务器——KestrelServer"], "link": ["http://www.cnblogs.com/artech/p/KestrelServer.html"], "desc": ["摘要: ", "跨平台是ASP.NET Core一个显著的特性，而KestrelServer是目前微软推出了唯一一个能够真正跨平台的Server。KestrelServer利用一个名为KestrelEngine的网络引擎实现对请求的监听、接收和响应。KetrelServer之所以具有跨平台的特质，源于KestrelEngine是在一个名为libuv的跨平台网络库上开发的。"]}
{"title": ["ASP.NET Core真实管道详解[2]：Server是如何完成针对请求的监听、接收与响应的【上】"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-core-pipeline-02.html"], "desc": ["摘要: ", "Server是ASP .NET Core管道的第一个节点，负责完整请求的监听和接收，最终对请求的响应同样也由它完成。Server是我们对所有实现了IServer接口的所有类型以及对应对象的统称，这个接口具有一个只读属性Features返回描述自身特性集合的FeatureCollection对象，另一个Start方法用于启动服务器。"]}
{"title": ["ASP.NET Core真实管道详解[1]：中间件是个什么东西？"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-core-pipeline-01.html"], "desc": ["摘要: ", "ASP.NET Core管道虽然在结构组成上显得非常简单，但是在具体实现上却涉及到太多的对象，所以我们在 《ASP.NET Core管道深度剖析[共4篇]》 中围绕着一个经过极度简化的模拟管道讲述了真实管道构建的方式以及处理HTTP请求的流程。在这个系列 中，我们会还原构建模拟管道时可以舍弃和改写的部分，想读者朋友们呈现一个真是的HTTP请求处理管道。 ASP.NET Core 的请求处理管道由一个Server和一组有序排列的中间件构成，前者仅仅完成基本的请求监听、接收和响应的工作，请求接收之后和响应之前的所有工作都交给注册的中间件来完成。ASP.NET Core的中间件通过一个类型Func"]}
{"title": [".NET Core下的日志（3）：如何将日志消息输出到控制台上"], "link": ["http://www.cnblogs.com/artech/p/log-to-console.html"], "desc": ["摘要: ", "当我们利用LoggerFactory创建一个Logger对象并利用它来实现日志记录，这个过程会产生一个日志消息，日志消息的流向取决于注册到LoggerFactory之上的LoggerProvider。说的更加具体一点，日志消息的归宿取决于注册到LoggerFactory的LoggerProvider究竟会提供怎样的Logger。微软提供了一系列原生的LoggerProvider，我们先来认识一下将控制台作为日志输出目的地的ConsoleLoggerProvider"]}
{"title": ["“前.NET Core时代”如何实现跨平台代码重用 ——程序集重用"], "link": ["http://www.cnblogs.com/artech/p/assemby-resuse-for-x-platform.html"], "desc": ["摘要: ", "除了在源代码层面实现共享（“前.NET Core时代”如何实现跨平台代码重用 ——源文件重用）之外，我们还可以跨平台共享同一个程序集，这种独立于具体平台的“中性”程序集通过创建一种名为“可移植类库（PCL： Portable Class Library）”项目来实现。为了让读者朋友们对PCL的实现机制具有充分的认识，我们先来讨论一个被我称为“程序集动态绑定”的话题。"]}
{"title": ["“前.NET Core时代”如何实现跨平台代码重用 ——源文件重用"], "link": ["http://www.cnblogs.com/artech/p/source-file-reuse.html"], "desc": ["摘要: ", "对于包括Mono在内的各个.NET Framework平台的BCL（Basic Class Library）来说，虽然在API定义层面上存在一些共同之处，但是由于它们定义在不同的程序集之中，所以在PCL（Portal Class Library）推出之前，针对程序集的共享是不可能实现的，我们只能在源代码层面实现共享。源代码的共享通过在不同项目（针对不同.NET Framework平台）之间共享源文件的方式来实现，至于具体采用的方式，我们有三种不同的方案供你选择。"]}
{"title": [".NET Core下的日志（2）：日志模型详解"], "link": ["http://www.cnblogs.com/artech/p/inside-net-core-logging-2.html"], "desc": ["摘要: ", "NET Core的日志模型主要由三个核心对象构成，它们分别是Logger、LoggerProvider和LoggerFactory。总的来说，LoggerProvider提供一个具体的Logger对象将格式化的日志消息写入相应的目的地，但是我们在编程过程中使用的Logger对象则由LoggerFactory创建，这个Logger利用注册到LoggerFactory的LoggerProvider来提供真正具有日志写入功能的Logger，并委托后者来记录日志。"]}
{"title": [".NET Core下的日志（1）：记录日志信息"], "link": ["http://www.cnblogs.com/artech/p/inside-net-core-logging.html"], "desc": ["摘要: ", "记录各种级别的日志是所有应用不可或缺的功能。关于日志记录的实现，我们有太多第三方框架可供选择，比如Log4Net、NLog、Loggr和Serilog 等，当然我们还可以选择微软原生的诊断机制（相关API定义在命名空间“System.Diagnostics”中）实现对日志的记录。.NET Core提供了独立的日志模型使我们可以采用统一的API来完成针对日志记录的编程，我们同时也可以利用其扩展点对这个模型进行定制，比如可以将上述这些成熟的日志框架整合到我们的应用中"]}
{"title": ["ASP.NET Core 1.0中实现文件上传的两种方式（提交表单和采用AJAX）", "ASP.NET Core管道深度剖析[共4篇]"], "link": ["http://www.cnblogs.com/artech/p/upload-files-in-asp-net-core.html", "http://www.cnblogs.com/artech/p/inside-asp-net-core-pipeline.html"], "desc": ["摘要: ", "Uploading files is a common requirement in web applications. In ASP.NET Core 1.0 uploading files and saving them on the server is quite easy. To that end this article shows how to do just that.Begin by creating a new ASP.NET Core project. Then add HomeController to the controllers folder. Then add UploadFiles view to Views > Home folder of the application.", "摘要: ", "之所以称ASP.NET Core是一个Web开发平台，源于它具有一个极具扩展性的请求处理管道，我们可以通过这个管道的定制来满足各种场景下的HTTP处理需求。ASP. NET Core应用的很多特性，比如路由、认证、会话、缓存等，也同时定制消息处理管道来实现的。我们甚至可以通过管道定制在ASP.NET Core平台上创建我们自己的Web框架，实际上MVC和SingalR这两个重要的Web框架也是采用这样的方式创建的。"]}
{"title": ["ASP.NET Core管道深度剖析（4）：管道是如何建立起来的？"], "link": ["http://www.cnblogs.com/artech/p/how-pipeline-is-built.html"], "desc": ["摘要: ", "在《管道是如何处理HTTP请求的？》中，我们对ASP.NET Core的请求处理管道的构成以及它对请求的处理流程进行了详细介绍，接下来我们需要了解的是这样一个管道是如何被构建起来的。这样一个管道由一个服务器和一个HttpApplication构成，前者负责监听请求并将接收的请求传递给给HttpAppkication对象处理，后者则将请求处理任务委托给注册的中间件来完成。"]}
{"title": ["ASP.NET Core管道深度剖析（3）：管道是如何处理HTTP请求的？"], "link": ["http://www.cnblogs.com/artech/p/how-pipeline-process-request.html"], "desc": ["摘要: ", "我们知道ASP.NET Core请求处理管道由一个服务器和一组有序的中间件组成，所以从总体设计来讲是非常简单的，但是就具体的实现来说，由于其中涉及很多对象的交互，我想很少人能够地把它弄清楚。为了让读者朋友们能够更加容易地理解管道处理HTTP请求的总体流程，我们根据真实管道的实现原理再造了一个“模拟管道”并在此管道上开发了一个发布图片的应用，这篇文章旨在为你讲述管道是如何处理HTTP请求的"]}
{"title": ["ASP.NET Core管道深度剖析（2）：创建一个“迷你版”的管道来模拟真实管道请求处理流程"], "link": ["http://www.cnblogs.com/artech/p/mini-asp-net-core-pipeline.html"], "desc": ["摘要: ", "如果想非常深刻地认识ASP.NET Core的请求处理管道，可以分两个步骤来进行，我们首先可以在忽略细节的前提下搞清楚管道处理HTTP请求的总体流程，然后再此基础上补充之前遗漏的细节。为了让读者朋友们能够更加容易地理解管道处理HTTP请求的总体流程，我们根据真实管道的实现原理再造了一个“模拟管道”。"]}
{"title": ["ASP.NET Core管道深度剖析（1）：采用管道处理HTTP请求"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-pipeline.html"], "desc": ["摘要: ", "之所以称ASP.NET Core是一个Web开发平台，源于它具有一个极具扩展性的请求处理管道，我们可以通过这个管道的定制来满足各种场景下的HTTP处理需求。ASP. NET Core应用的很多特性，比如路由、认证、会话、缓存等，也同时定制消息处理管道来实现的。我们甚至可以通过管道定制在ASP.NET Core平台上创建我们自己的Web框架，实际上MVC和SingalR这两个重要的Web框架也是采用这样的方式创建的。"]}
{"title": ["How to debug .NET Core RC2 app with Visual Studio Code on Windows?"], "link": ["http://www.cnblogs.com/artech/p/debug-in-vs-code.html"], "desc": ["摘要: ", "So, you installed .NET Core RC2 , you followed the getting started tutorial and you got your “Hello World!” printed on your command prompt just by using the CLI. Then you went the next step and you tried to use Visual Studio Code and the C# extension to edit the application outside of Visual Studio. And finally you want to try and debug and set a breakpoint inside the application, but you encountered some pr"]}
{"title": ["难道.NET Core到R2连中文编码都不支持吗？"], "link": ["http://www.cnblogs.com/artech/p/encoding-registeration-4-net-core.html"], "desc": ["摘要: ", "今天写了一个简单的.NET Core RC2控制台程序，发现中文显示一直是乱码。查看操作系统设置，没有问题；查看源文件编码，也没有问题；甚至查看了Console字符编码相关的注册表，依然没有发现问题。难道NET Core到了RC2，莫非连一些常用的编码都不支持吗？"]}
{"title": [".NET Core RC2发布在即，我们试着用记事本编写一个ASP.NET Core RC2 MVC程序"], "link": ["http://www.cnblogs.com/artech/p/hello-asp-net-core-rc2-mvc.html"], "desc": ["摘要: ", "在.NET Core 1.0.0 RC2即将正式发布之际，我也应应景，针对RC2 Preview版本编写一个史上最简单的MVC应用。由于VS 2015目前尚不支持，VS Code的智能感知尚欠火候，所以我们直接采用最原始的记事本来编写这个MVC应用。"]}
{"title": [".NET Core全新的配置管理[共9篇]"], "link": ["http://www.cnblogs.com/artech/p/config-for-net-core.html"], "desc": ["摘要: ", "提到“配置”二字，我想绝大部分.NET开发人员脑海中会立马浮现出两个特殊文件的身影，那就是我们再熟悉不过的app.config和web.config，多年以来我们已经习惯了将结构化的配置信息定义在这两个文件之中。到了.NET Core的时候，很多我们习以为常的东西都发生了改变，其中也包括定义配置的方式。总的来说，新的配置系统显得更加轻量级，并且具有更好的扩展性，其最大的特点就是支持多样化的数据源。我们可以采用内存的变量作为配置的数据源，也可以直接配置定义在持久化的文件甚至数据库中。"]}
{"title": ["ASP.NET Core中的project.json何去何从？", "The .NET of Tomorrow"], "link": ["http://www.cnblogs.com/artech/p/The-Future-of-project-json-in-ASP-NET-Core.html", "http://www.cnblogs.com/artech/p/the-net-of-tomorrow.html"], "desc": ["摘要: ", "Microsoft has decided after the RTM of the ASP.NET Core framework to phase out project.json and use MSBuild for build data. They’ve not decided whether to keep the NuGet dependencies in a pared down project.json (maybe renamed to nuget.json) or whether to just allow for a command-line action like “nuget install dependency --save” to mirror what other package managers do.", "摘要: ", "Exciting times lie ahead for .NET developers. During Build, Microsoft’s biggest developer event of the year, clear roadmaps were given on the future of .NET and C#. Microsoft is re-positioning .NET to be a platform that can be written anywhere and run anywhere, which is a departure from it’s long history of proprietary technologies."]}
{"title": ["ASP.NET Core的配置（5）：配置的同步[设计篇]", "谁是2016年的.NET开发者？"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-5-2.html", "http://www.cnblogs.com/artech/p/the-dotnet-developer-of-2016.html"], "desc": ["摘要: ", "本节所谓的“配置同步”主要体现在两个方面：其一，如何监控配置源并在其变化的时候自动加载其数据，其目的是让应用中通过Configuration对象承载的配置与配置源的数据同步；其二、当Configuration对象承载的配置放生变换的时候如何向应用程序发送通知，最终让应用程序使用最新的配置。", "摘要: ", "Whether you have already drawn insights from our (free) 2016 .NET Developer Community Report or not, you will likely find this new slice of the results delicious. This infographic presents a few interesting cross-sections of data from our 2016 .NET Developer Survey, some of which are not included in the report."]}
{"title": ["ASP.NET Core的配置（5）：配置的同步[ 实例篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-5-1.html"], "desc": ["摘要: ", "ConfigurationBuilder在生成以Configuration对象的时候会利用注册其中的ConfigurationProvider加载原始的配置数据，那么一旦配置源中的数据发生变化，应用程序中的使用的配置信息如何与之同步呢？如果需要在应用程序中实现对配置信息的实施同步，就需要对原始配置数据的进行监控，并在数据改变的时候重新加载配置数据。除此之外，重新加载的配置需要应用到程序中，我们必然需要一种通知机制。"]}
{"title": ["ASP.NET Core 中的依赖注入 [共7篇]"], "link": ["http://www.cnblogs.com/artech/p/di-4-asp-net-core.html"], "desc": ["摘要: ", "ASP.NET Core在启动以及后续针对每个请求的处理过程中的各个环节都需要相应的组件提供相应的服务，为了方便对这些组件进行定制，ASP.NET通过定义接口的方式对它们进行了“标准化”，我们将这些标准化的组件称为服务，ASP.NET在内部专门维护了一个DI容器来提供所需的服务"]}
{"title": ["ASP.NET Core的配置（4）：多样性的配置来源[下篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-4-3.html"], "desc": ["摘要: ", "我们在上篇和中篇对配置模型中默认提供的各种ConfigurationProvider进行了深入详尽的介绍，如果它们依然不能满足项目中的配置需求，我们可以还可以通过自定义ConfigurationProvider来支持我们希望的配置来源。就配置数据的持久化方式来说，将配置存储在数据库中应该是一种非常常见的方式，接下来我们就是创建一个针对数据库的ConfigurationProvider，它采用最新的Entity Framework 7来完成数据库的存取操作。"]}
{"title": ["ASP.NET Core的配置（4）：多样性的配置来源[中篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-4-2.html"], "desc": ["摘要: ", "我们在本篇文章中会介绍三种针对物理文件的ConfiguationProvider，它们分别是针对JSON文件的JsonConfiguationProvider，针对XML文件的XmlConfiguationProvider以及针对INI文件的IniConfiguationProvider。对于这三种文件类型（JSON、XML和INI）来说，JSON能够采用简单直观的格式表示具有不同结构的数据，所以它是作为配置最好的选择。"]}
{"title": ["ASP.NET Core的配置（4）：多样性的配置来源[上篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-4-1.html"], "desc": ["摘要: ", "较之传统通过App.config和Web.config这两个XML文件承载的配置系统，ASP.NET Core采用的这个全新的配置模型的最大一个优势就是针对多种不同配置源的支持。我们可以将内存变量、命令行参数、环境变量和物理文件作为原始配置数据的来源，如果采用物理文件作为配置源，我们可以选择不同的格式，比如XML、JSON和INI等。如果这些默认支持的配置源形式还不能满足你的需求，我们还可以通过注册自定义ConfigurationProvider的方式将其他形式数据作为我们的配置来源。接下来就让我们来逐个认识一下配置模型原生提供的ConfigurationProvider。"]}
{"title": ["ASP.NET Core的配置（3）： 将配置绑定为对象[下篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-04.html"], "desc": ["摘要: 我们在《读取配置信息》通过实例的形式演示了如何利用Options模型以依赖注入的方式直接获取由指定配置节绑定生成的Options对象，我们再次回顾一下当初我们编写的程序。如下面的代码片段所示，基于Options模型的配置绑定的编程基本采用这样的模式：先后调用ServiceCollection的扩展方法AddOption和Configure注册Options模型相关的服务并完成Options类型与指定配置节之间的映射，然后利用由此生成ServiceProvider获得一个类型为IOptions"]}
{"title": ["ASP.NET Core的配置（3）： 将配置绑定为对象[上篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-03.html"], "desc": ["摘要: ", "出于编程上的便利，我们通常不会直接利用ConfigurationBuilder创建的Configuration对象读取某个单一配置项的值，而是倾向于将一组相关的配置绑定为一个对象，我们将后者称为Options对象。我们在本章第一节通过简单的实例演示了如何利用Options模型实现了配置数据向Options对象的绑定，现在我们对Options模型背后的实现原理进行详细介绍。"]}
{"title": ["ASP.NET Core的配置（2）：配置模型详解"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-02.html"], "desc": ["摘要: ", "在上面一章我们以实例演示的方式介绍了几种读取配置的几种方式，其中涉及到三个重要的对象，它们分别是承载结构化配置信息的Configuration，提供原始配置源数据的ConfigurationProvider，以及作为“中间人”的ConfigurationBuilder。现在我们对 以这三个对象为核心的配置模型进行深入介绍。"]}
{"title": ["ASP.NET Core的配置（1）：读取配置信息"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-config-01.html"], "desc": ["摘要: ", "提到“配置”二字，我想绝大部分.NET开发人员脑海中会立马浮现出两个特殊文件的身影，那就是我们再熟悉不过的app.config和web.config，多年以来我们已经习惯了将结构化的配置信息定义在这两个文件之中。到了.NET Core的时候，很多我们习以为常的东西都发生了改变，其中也包括定义配置的方式。总的来说，新的配置系统显得更加轻量级，并且具有更好的扩展性，其最大的特点就是支持多样化的数据源。我们可以采用内存的变量作为配置的数据源，也可以直接配置定义在持久化的文件甚至数据库中。"]}
{"title": ["ASP.NET Core中的依赖注入（5）：ServicePrvider实现揭秘【补充漏掉的细节】"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-3.html"], "desc": ["摘要: ", "到目前为止，我们定义的ServiceProvider已经实现了基本的服务提供和回收功能，但是依然漏掉了一些必需的细节特性。这些特性包括如何针对IServiceProvider接口提供一个ServiceProvider对象，何创建ServiceScope，以及如何提供一个服务实例的集合。"]}
{"title": ["ASP.NET Core中的依赖注入（5）: ServiceProvider实现揭秘 【解读ServiceCallSite 】"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-2.html"], "desc": ["摘要: ", "通过上一篇的介绍我们应该对实现在ServiceProvider的总体设计有了一个大致的了解，但是我们刻意回避一个重要的话题，即服务实例最终究竟是采用何种方式提供出来的。ServiceProvider最终采用何种方式提供我们所需的服务实例取决于最终选择了怎样的ServiceCallSite，而服务注册是采用的ServiceDescriptor有决定了ServiceCallSite类型的选择。我们将众多不同类型的ServiceCallSite大体分成两组，一组用来创建最终的服务实例，另一类则与生命周期的管理有关。"]}
{"title": ["ASP.NET Core中的依赖注入（5）: ServiceProvider实现揭秘 【总体设计 】"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-service-provider-1.html"], "desc": ["摘要: ", "本系列前面的文章我们主要以编程的角度对ASP.NET Core的依赖注入系统进行了详细的介绍，如果读者朋友们对这些内容具有深刻的理解，我相信你们已经可以正确是使用这些与依赖注入相关的API了。如果你还对这个依赖注入系统底层的实现原理具有好奇心，可以继续阅读这一节的内容。"]}
{"title": ["ASP.NET Core中的依赖注入（4）: 构造函数的选择与服务生命周期管理"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-life-time.html"], "desc": ["摘要: ", "ServiceProvider最终提供的服务实例都是根据对应的ServiceDescriptor创建的，对于一个具体的ServiceDescriptor对象来说，如果它的ImplementationInstance和ImplementationFactory属性均为Null，那么ServiceProvider最终会利用其ImplementationType属性返回的真实类型选择一个适合的构造函数来创建最终的服务实例。我们知道服务服务的真实类型可以定义了多个构造函数，那么ServiceProvider针对构造函数的选择会采用怎样的策略呢？"]}
{"title": ["ASP.NET Core中的依赖注入（3）: 服务的注册与提供"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-register.html"], "desc": ["摘要: ", "在采用了依赖注入的应用中，我们总是直接利用DI容器直接获取所需的服务实例，换句话说，DI容器起到了一个服务提供者的角色，它能够根据我们提供的服务描述信息提供一个可用的服务对象。ASP.NET Core中的DI容器体现为一个实现了IServiceProvider接口的对象。ASP.NET Core针对依赖注入的编程主要体现在两个方面：其一，创建一个ServiceCollection对象并将服务注册信息以ServiceDescriptor对象的形式添加其中；其二，针对ServiceCollection对象创建对应的ServiceProvider并利用它提供我们需要的服务实例。"]}
{"title": ["ASP.NET Core中的依赖注入（2）：依赖注入（DI）"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-di.html"], "desc": ["摘要: ", "IoC主要体现了这样一种设计思想：通过将一组通用流程的控制从应用转移到框架之中以实现对流程的复用，同时采用“好莱坞原则”是应用程序以被动的方式实现对流程的定制。我们可以采用若干设计模式以不同的方式实现IoC，比如我们在上面介绍的模板方法、工厂方法和抽象工厂，接下来我们介绍一种更为有价值的IoC模式，即依赖注入（DI：Dependency Injection，以下简称DI）。"]}
{"title": ["ASP.NET Core中的依赖注入（1）：控制反转（IoC）"], "link": ["http://www.cnblogs.com/artech/p/asp-net-core-di-ioc.html"], "desc": ["摘要: ", "ASP.NET Core在启动以及后续针对每个请求的处理过程中的各个环节都需要相应的组件提供相应的服务，为了方便对这些组件进行定制，ASP.NET通过定义接口的方式对它们进行了“标准化”，我们将这些标准化的组件称为服务，ASP.NET在内部专门维护了一个DI容器来提供所需的服务。要了解这个DI容器以及现实其中的服务提供机制，我们先得知道什么是DI（Dependence Injection），而一旦我们提到DI，又不得不说IoC（Inverse of Control）。"]}
{"title": ["初学ReactJS，写了一个RadioButtonList组件"], "link": ["http://www.cnblogs.com/artech/p/react-demo-radio-button-list.html"], "desc": ["摘要: ReactJS学习日志"]}
{"title": ["这算是ASP.NET MVC的一个大BUG吗？"], "link": ["http://www.cnblogs.com/artech/p/asp-net-mvc-bug.html"], "desc": ["摘要: ", "这是昨天一个同事遇到的问题，我觉得这是一个蛮大的问题，而且应该不是ASP.NET MVC的设计者有意为之，换言之，这可能是ASP.NET MVC的一个大Bug。"]}
{"title": ["通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（3）"], "link": ["http://www.cnblogs.com/artech/p/asp-net-5-hello-world-03.html"], "desc": ["摘要: ", "设置自定义的入口程序体现应用本身与应用托管之间的分离，它使我们可以创建独立于托管环境的应用，并根据需要寄宿于任何一个我们希望的宿主程序下，对于Web应用来说这一点尤为重要。对于之前的Web应用来说，IIS是它们唯一的宿主，但是ASP.NET 5应用却可以将我们指定的入口程序作为宿主。如果将应用寄宿于我们指定的宿主程序，这样的寄宿方式被称为Self-Host，接下来我们通过一个具体的例子来演示如何定义一个简单的ASP.NET MVC应用，并采用Self-Host的方式启动它。"]}
{"title": ["通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（2）", "通过3个Hello World应用来了解ASP.NET 5应用是如何运行的（1）"], "link": ["http://www.cnblogs.com/artech/p/asp-net-5-hello-world-02.html", "http://www.cnblogs.com/artech/p/asp-net-5-hello-world-01.html"], "desc": ["摘要: ", "对于上面创建的这个Hello World应用来说，程序入口点由应用自身来提供，所以应用本身具有自我执行的能力。从应用托管（Host）的角度来讲，这样的应用同时负责对自身的托管。将应用与托管环境独立起来其实是更好的选择，因为这样可以使同一个应用运行于不同的环境中。接下来我们就来演示如何为应用指定入口程序来达到应用与应用托管的分离。", "摘要: ", "微软在开发ASP.NET 5（当时被称为ASP.NET vNext）是采用的代号为Project K，所以运行时被称为KRuntime。KRuntime是一个SDK，它包含了编译和运行应用程序的所有资源。接下来我们通过三个Hello World实例来演示如何利用KRuntime让我们编写的应用运行起来。这三个实例如此的简单，以至于我们根本不需要利用IDE来编写。作为第一个Hello World应用，我们会编写一个包含入口点的程序，并通过执行KRuntime的K.cmd命令来启动它。"]}
{"title": ["感恩回馈，新鲜出炉的《ASP.NET MVC 5框架揭秘》免费赠送"], "link": ["http://www.cnblogs.com/artech/p/book-as-a-present-2.html"], "desc": ["摘要: ", "上次针对《ASP.NET Web API 2框架揭秘》举办了一次评论赠书活动，很多人问我相同的活动要不要针对《ASP.NET MVC 5框架揭秘》再来一次，为此我向出版社要了10本，其中5本以评论博客的形式送出，另5本则以转发微博的形式送出."]}
{"title": ["《ASP.NET MVC 5框架揭秘》样章发布"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework-demo.html"], "desc": ["摘要: ", "今天算是新作《ASP.NET MVC 5框架揭秘》正式上架销售的日子（目前本书在互动网已经到货），为了让更多适合的朋友们能够阅读此书，同时也避免让不适合的读者误买此书，特将此书的样章发布出来。"]}
{"title": ["新作《ASP.NET MVC 5框架揭秘》正式出版"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-mvc-5-framework.html"], "desc": ["摘要: ", "本书以一个模拟ASP.NET MVC内部运行机制的“迷你版MVC框架”作为开篇，其目的在于将ASP.NET MVC真实架构的“全景”勾勒出来。接下来本书以请求消息在ASP.NET MVC框架内部的流向为主线将相关的知识点串连起来，力求将”黑盒式”的消息处理管道清晰透明地展示在读者面前。相信精读本书的读者一定能够将ASP.NET MVC从接收请求到响应回复的整个流程了然于胸，对包括路由、Controller的激活、Model元数据的解析、Action方法的选择与执行、参数的绑定与验证、过滤器的执行以及View的呈现等相关的机制具有深刻的理解。本书以实例演示的方式介绍了很多与ASP.NET MVC相关的最佳实践，同时还提供了一系列实用性的扩展，相信它们一定能够解决你在真实开发过程中遇到的很多问题。本书最后一章提供的案例不仅仅用于演示实践中的ASP.NET MVC，很多的架构设计方面的东西也包含其中。除此之"]}
{"title": ["感恩回馈，《ASP.NET Web API 2框架揭秘》免费赠送"], "link": ["http://www.cnblogs.com/artech/p/book-as-a-present.html"], "desc": ["摘要: ", "在继《WCF全面解析》、《ASP.NET MVC 4框架揭秘》之后，我的另一本书《ASP.NET Web API 2框架揭秘》于本月正式出版，《ASP.NET MVC 5框架揭秘》也即将推出。这几本上算畅销的技术书籍的出版源于多年写博客的积累，所以离不开博客园这个平台和广大网友的支持。作为回馈，我也学学汤姆大叔来一个评论送书活动。"]}
{"title": ["《ASP.NET Web API 2框架揭秘》样章（PDF版本）", "新作《ASP.NET Web API 2框架揭秘》正式出版"], "link": ["http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework-sample.html", "http://www.cnblogs.com/artech/p/inside-asp-net-web-api-2-framework.html"], "desc": ["摘要: ", "《ASP.NET Web API 2框架揭秘》以实例演示的方式介绍了很多与ASP.NET Web API相关的最佳实践，同时还提供了一系列实用性的扩展。本书详细讲解了ASP.NET Web API从接收请求到响应回复的整个流程，包括路由、Http Controller的激活、Action方法的选择与执行、参数的绑定与验证、过滤器的执行和安全等相关的机制。", "摘要: ", "本书以实例演示的方式介绍了很多与ASP.NET Web API相关的最佳实践，同时还提供了一系列实用性的扩展。本书详细讲解了ASP.NET Web API从接收请求到响应回复的整个流程，包括路由、Http Controller的激活、Action方法的选择与执行、参数的绑定与验证、过滤器的执行和安全等相关的机制。除此之外，本书在很多章节还从设计的角度对ASP.NET Web API的架构进行了深入分析，所以可以将本书当作一本架构设计的书来读。虽然与市面上任何一本相关的书相比，本书走得更远并更加近距离地触及到ASP.NET Web API框架的内核，但是就其内容本身来讲却没有涉及太多“高深莫测”的知识点，所以阅读本书不存在太高的门槛。如果你觉得自己对ASP.NET Web API所知甚少，可以利用此书来系统地学习ASP.NET Web API；如果你觉得自己对ASP.NET Web API足够精通，也一"]}
{"title": ["ASP.NET MVC下的四种验证编程方式[续篇]"], "link": ["http://www.cnblogs.com/artech/p/asp-net-mvc-4-validation.html"], "desc": ["摘要: ", "在《ASP.NET MVC下的四种验证编程方式》一文中我们介绍了ASP.NET MVC支持的四种服务端验证的编程方式（“手工验证”、“标注ValidationAttribute特性”、“让数据类型实现IValidatableObject或者IDataErrorInfo”），那么在ASP.NET MVC框架内部是如何提供针对这四种不同编程方式的支持的呢？接下来我们就来聊聊这背后的故事。"]}
